#!/usr/bin/env psybeam

with { std, psybeam };
let { string, option, iter } = std;
let { command, label_color, read_to_string } = psybeam;

let palette = {
	let color = psybeam.color.hex;

	blue: (color "#46c0ea"),
	green: (color "#9dffa4"),
	white: (color "#cccccc"),
	pink: (color "#c6507b"),
	red: (color "#9f1457")
};

# Widgets

let network = psybeam.widget.new
	title: "Network Name",
	width: 192,
	refresh: (psybeam.widget.refresh.timer.s 10),
	draw: {
		let^ palette, string, command, label_color;

		with _widget;

		# TODO: attempt other known network manager commands.
		let output = command "iwgetid", "--raw";
		# This doesn't check the exit code because
		# empty stdout works instead.
		let name = string.trim_whitespace output.stdout;
		let text = if name != "" then
			string.concat name, " "
		else then
			string.concat "? (error ", (string.from_i64 output.status), ")"
		end;

		label_color text, palette.blue
	};

let cpu = psybeam.widget.new
	title: "CPU Usage",
	width: 64,
	refresh: (psybeam.widget.refresh.timer.s 5),
	draw: {
		let^ palette, string, iter, option, label_color, read_to_string;

		# cpu usage involves diffing the current and last known values of /proc/stat
		let last_timing = (
			idle: 0,
			total: 0
		);

		with _widget;

		let timings = read_to_string "/proc/stat"
			# the first line of /proc/stat is total cpu time...
			|> string.split "\n"
			|> iter.reduce_once ()
			|> option.unwrap()
			# ...each entry is a space-separated integer...
			|> string.split_whitespace ()
			# ...except for the first one, which is always "cpu".
			|> iter.skip 1;

		let current_timing = (
			idle: (
				timings
					# the 4th entry is idle cpu time
					|> iter.skip 3
					|> iter.reduce_once ()
					|> option.unwrap()
					|> string.parse_i64 ()
					|> option.unwrap()
			),
			total: (
				timings
					|> iter.map {
						let^ string, option;
						with i;
						string.parse_i64 i |> option.unwrap()
					}
					|> iter.fold 0, {
						with (a, x);
						a + x
					}
			)
		);
		let idle_diff = current_timing.idle - last_timing.idle;
		let total_diff = current_timing.total - last_timing.total;
		let usage = string.from_i64 (total_diff - idle_diff) * 100 / total_diff;
		# set last_timing = current_timing;

		# this file is a comma-seperated list of minus-separated ranges of cpus.
		let present_cpus = read_to_string "/sys/devices/system/cpu/present";
		let cores = present_cpus
			|> string.trim_whitespace ()
			|> string.split ","
			|> iter.map {
				let^ iter, string, option;

				with range;

				let range_iter = range
					|> string.split "-"
					|> iter.map string.parse_i64
					|> iter.map option.unwrap;
				let (first, range_iter) = range_iter
					|> iter.next ()
					|> option.unwrap ();
				let last = range_iter
					|> iter.reduce_once ()
					# If last is absent, treat the range as `first-first`
					|> option.unwrap_or first;
				last - first + 1
			}
			|> iter.fold 0, { with (a, x); a + x }
			|> string.from_i64 ();

		string.concat usage, "% "
			|> label_color palette.green
	};

let memory = psybeam.widget.new
	title: "Memory Usage",
	width: 64,
	refresh: (psybeam.widget.refresh.timer.s 5),
	draw: {
		let^ palette, string, iter, option, label_color, read_to_string;

		with _widget;

		let meminfo = read_to_string "/proc/meminfo"
			|> string.split "\n"
			# TODO: These option.unwraps could be replaced with a filter_map & maybe monad
			|> iter.map {
				let^ string, iter, option;
				with line;
				let label = string.split_whitespace line
					|> iter.reduce_once ()
					|> option.unwrap ();
				let value = string.split_whitespace line
					|> iter.skip 1
					|> iter.reduce_once ()
					|> option.unwrap ();
				label, value
			};

		let get_meminfo = {
			let^ iter, meminfo;
			with label;
			iter.find_map meminfo, {
				let^ label;
				with (candidate, value);
				if candidate == label then
					(Option String).Some value
				else then
					(Option String).None ()
				end
			}
		};

		let available = get_meminfo "MemAvailable:"
			|> option.unwrap ()
			|> string.parse_i64 ()
			|> option.unwrap();
		let total = get_meminfo "MemTotal:"
			|> option.unwrap ()
			|> string.parse_i64 ()
			|> option.unwrap();
		let usage = (total - available) * 100 / total
			|> string.from_i64 ();

		string.concat usage, "% "
			|> label_color palette.white
	};

let battery = {
	let^ palette, string, iter, option, label_color, read_to_string, psybeam;
	with power_supply;

	psybeam.widget.new
		title: "Battery",
		width: 64,
		refresh: (psybeam.widget.refresh.timer.s 60),
		draw: {
			let^ power_supply, palette, string, iter, option, label_color, read_to_string;

			with _widget;

			let property = {
				let^ string, power_supply;
				with property;
				string.concat "/sys/class/power_supply/", power_supply, "/", property
			};
			let capacity = read_to_string (property "capacity")
				|> string.trim_whitespace ();
			let status = read_to_string (property "status")
				|> string.trim_whitespace ();
			let icon =
				if status == "Discharging"
				or status == "Not charging"
				or status == "Full"
			then
				let capacity = capacity
					|> string.parse_i64 ()
					|> option.unwrap ();

				if capacity > 90 then "" else
				if capacity > 75 then "" else
				if capacity > 50 then "" else
				if capacity > 25 then "" else
				                 then "" end
			else if status == "Charging" then
				""
			else then
				status
			end;

			string.concat capacity, "% ", icon
				|> label_color palette.pink
		}
};

let clock = psybeam.widget.new
	title: "Clock",
	width: 64,
	refresh: (psybeam.widget.refresh.timer.s 60),
	draw: {
		let^ palette, string, command, label_color;

		with _widget;

		(command "date", "+%H:%M").stdout
			|> string.trim_whitespace ()
			|> label_color palette.red
	};

# Config

surface: (
	height: 32
),
layout: (
	network,

	psybeam.widget.spacer,

	cpu,
	memory,
	# run `ls /sys/class/power_supply` to see possible batteries.
	(battery "BAT1"),

	psybeam.widget.spacer,

	clock
)
