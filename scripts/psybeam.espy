with { std, psybeam };

let read_file = {
	let { command } = psybeam;
	with path;
	(command "cat", path).stdout
};

let palette = {
	let color = psybeam.color.hex;

	blue: (color "#0000FF"),
	green: (color "#00FF00"),
	white: (color "#FFFFFF"),
	pink: (color "#FF8080"),
	red: (color "#FF0000")
};

# Widgets

let network = {
	let { string, iter, option } = std;
	let { command, label_color } = psybeam;
	let palette = palette;

	with _widget;

	# TODO: attempt other known network manager commands.
	let output = command "iwgetid", "--raw";
	# This doesn't check the exit code because
	# empty stdout works instead.
	let name = string.trim_whitespace output.stdout;
	let text = if name != "" then
		string.concat name, " "
	else then
		string.concat "? (error ", (string.from_i64 output.status), ")"
	end;

	label_color text, palette.blue
};

let cpu = {
	let { command, label_color } = psybeam;
	let { string, iter, option } = std;
	let palette = palette;
	let read_file = read_file;

	# cpu usage involves diffing the current and last known values of /proc/stat
	# by initializing this to 0, the first render will show net usage; not useful, but something.
	let last_timing = mut (
		idle: 0,
		total: 0
	);

	with _widget;

	let timings = read_file "/proc/stat"
		# the first line of /proc/stat is total cpu time...
		|> string.split "\n"
		|> iter.reduce_once ()
		|> option.unwrap()
		# ...each entry is a space-separated integer...
		|> string.split_whitespace ()
		# ...except for the first one, which is always "cpu".
		|> iter.skip 1;

	let current_timing = (
		idle: (
			timings
				# the 4th entry is idle cpu time
				|> iter.skip 3
				|> iter.reduce_once ()
				|> option.unwrap()
				|> string.parse_i64 ()
				|> option.unwrap()
		),
		total: (
			timings
				|> iter.map {
					let string = string;
					let option = option;
					with i;
					string.parse_i64 i |> option.unwrap()
				}
				|> iter.fold 0, {
					with (a, x);
					a + x
				}
		)
	);
	let idle_diff = current_timing.idle - last_timing.*.idle;
	let total_diff = current_timing.total - last_timing.*.total;
	let usage = string.from_i64 (total_diff - idle_diff) * 100 / total_diff;
	set last_timing = current_timing;

	# this file is a comma-seperated list of minus-separated ranges of cpus.
	let present_cpus = read_file "/sys/devices/system/cpu/present";
	let cores = present_cpus
		|> string.trim_whitespace ()
		|> string.split ","
		|> iter.map {
			let iter = iter;
			let string = string;
			let option = option;

			with range;

			let range_iter = range
				|> string.split "-"
				|> iter.map string.parse_i64
				|> iter.map option.unwrap;
			# TODO: another use for a dedicated next function. or maybe `collect` into a tuple.
			let first = range_iter
				|> iter.reduce_once ()
				|> option.unwrap ();
			let last = range_iter
				|> iter.skip 1
				|> iter.reduce_once ()
				# If last is absent, treat the range as `first-first`
				|> option.unwrap_or first;
			last - first + 1
		}
		|> iter.fold 0, { with (a, x); a + x }
		|> string.from_i64 ();

	string.concat usage, "% "
		|> label_color palette.green
};

let memory = {
	let { command, label_color } = psybeam;
	let { string, iter, option } = std;
	let palette = palette;
	let read_file = read_file;

	with _widget;

	let meminfo = read_file "/proc/meminfo";
	# TODO: use filter/find instead of fold.
	let { available, total } = meminfo
		|> string.split "\n"
		|> iter.fold (available: (Option String).None, total: (Option String).None), {
			let string = string;
			let iter = iter;
			let option = option;
			with ({ available, total }, line);

			# TODO: this could be better expressed as iter.next
			let label = string.split_whitespace line
				|> iter.reduce_once ();
			let value = string.split_whitespace line
				|> iter.skip 1
				|> iter.reduce_once();
			if label == ((Option String).Some "MemTotal:") then
				available: available, total: value
			else if label == ((Option String).Some "MemAvailable:") then
				available: value, total: total
			else then
				available: available, total: total
			end
		};
	let total = total
		|> option.unwrap ()
		|> string.parse_i64 ()
		|> option.unwrap();
	let available = available
		|> option.unwrap ()
		|> string.parse_i64 ()
		|> option.unwrap();
	let usage = (total - available) * 100 / total
		|> string.from_i64 ();

	string.concat usage, "% "
		|> label_color palette.white
};

let battery = {
	let { command, label_color } = psybeam;
	let { string, iter, option } = std;
	let palette = palette;
	let read_file = read_file;

	with _widget;

	let property = {
		# run `ls /sys/class/power_supply` to see possible batteries.
		let battery = "BAT0";
		let string = string;
		with property;
		string.concat "/sys/class/power_supply/", battery, "/", property
	};
	let capacity = read_file (property "capacity")
		|> string.trim_whitespace ();
	let status = read_file (property "status")
		|> string.trim_whitespace ();
	let icon = if status == "Discharging" then
		let capacity = capacity
			|> string.parse_i64 ()
			|> option.unwrap ();
		if capacity > 99 then
			""
		else if capacity > 75 then
			""
		else if capacity > 50 then
			""
		else if capacity > 25 then
			""
		else then
			""
		end
	else if status == "Charging" then
		""
	else then
		status
	end;

	string.concat capacity, "% ", icon
		|> label_color palette.pink
};

let clock = {
	let { command, label_color } = psybeam;
	let { iter, string, option } = std;
	let palette = palette;

	with _widget;

	(command "date", "+%H:%M").stdout
		|> string.trim_whitespace ()
		|> label_color palette.red
};

network,
	psybeam.spacer,
cpu, memory, battery,
	psybeam.spacer,
clock
