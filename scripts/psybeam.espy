with { std, psybeam };

let read_file = {
	let { command } = psybeam;
	with path;
	(command "cat", path).stdout
};

let palette = {
	let color = psybeam.color.hex;

	blue: (color "#0000FF"),
	green: (color "#00FF00"),
	white: (color "#FFFFFF"),
	pink: (color "#FF8080"),
	red: (color "#FF0000")
};

# Widgets

let network = {
	# TODO: rename this to `Option` to avoid the conflict with the `option` lib.
	let OptionString = option (std.typeof "string");
	let { string, iter, option } = std;
	let { command, label_color } = psybeam;
	let palette = palette;

	with _widget;

	# TODO: attempt other known network manager commands.
	let output = command "iwgetid", "--raw";
	# This doesn't check the exit code because
	# empty stdout works instead.
	let name = string.trim_whitespace output.stdout;
	let text = if name != "" then
		string.concat name, " "
	else then
		string.concat "? (error ", (string.from_i64 output.status), ")"
	end;

	label_color text, palette.blue
};

let cpu = {
	let OptionI64 = option i64;
	let { command, label_color } = psybeam;
	let { string, iter, option } = std;
	let palette = palette;
	let read_file = read_file;

	with _widget;

	let stat = read_file "/proc/stat";
	# TODO: This conceptually works but only displays uptime. deltas are necessary for recent usage
	let timings = stat
		|> string.split "\n"
		|> iter.reduce_once ()
		|> option.unwrap()
		|> string.split_whitespace ()
		|> iter.skip 1;
	let idle = timings
		|> iter.skip 3
		|> iter.reduce_once ()
		|> option.unwrap()
		|> string.parse_i64 ()
		|> option.unwrap();
	let total = timings
		|> iter.map {
			let string = string;
			let option = option;
			with i;
			string.parse_i64 i |> option.unwrap()
		}
		|> iter.fold 0, {
			with (a, x);
			a + x
		};
	let usage = string.from_i64 (total - idle) * 100 / total;

	# this file is a comma-seperated list of minus-separated ranges of cpus.
	let present_cpus = read_file "/sys/devices/system/cpu/present";
	let cores = present_cpus
		|> string.trim_whitespace ()
		|> string.split ","
		|> iter.map {
			let iter = iter;
			let string = string;
			let option = option;
			let OptionI64 = OptionI64;

			with range;

			let range_iter = range
				|> string.split "-"
				|> iter.map string.parse_i64
				|> iter.map option.unwrap;
			# TODO: another use for a dedicated next function. or maybe `collect` into a tuple.
			let first = range_iter
				|> iter.reduce_once ()
				|> option.unwrap ();
			let last = range_iter
				|> iter.skip 1
				|> iter.reduce_once ()
				# If last is absent, treat the range as `first-first`
				|> option.unwrap_or first;
			last - first + 1
		}
		|> iter.fold 0, { with (a, x); a + x }
		|> string.from_i64 ();

	string.concat usage, "% of ", cores, " cpus"
		|> label_color palette.green
};

let memory = {
	# TODO: expose string type!!!
	let OptionString = option (std.typeof "string");
	let { command, label_color } = psybeam;
	let { string, iter, option } = std;
	let palette = palette;
	let read_file = read_file;

	with _widget;

	let meminfo = read_file "/proc/meminfo";
	# TODO: use filter/find instead of fold.
	let { available, total } = meminfo
		|> string.split "\n"
		|> iter.fold (available: OptionString.None, total: OptionString.None), {
			let string = string;
			let iter = iter;
			let option = option;
			let OptionString = OptionString;
			with ({ available, total }, line);

			# TODO: this could be better expressed as iter.next
			let label = string.split_whitespace line
				|> iter.reduce_once ();
			let value = string.split_whitespace line
				|> iter.skip 1
				|> iter.reduce_once();

			if label == (OptionString.Some "MemTotal:") then
				available: available, total: value
			else if label == (OptionString.Some "MemAvailable:") then
				available: value, total: total
			else then
				available: available, total: total
			end
		};
	let total = total
		|> option.unwrap ()
		|> string.parse_i64 ()
		|> option.unwrap();
	let available = available
		|> option.unwrap ()
		|> string.parse_i64 ()
		|> option.unwrap();
	let reserved = (total - available) / 1024
		|> string.from_i64 ()
		# TODO: I don't know if i can rely on the initial unit to always be KiB
		|> string.concat "MiB";
	let total = total / 1024
		|> string.from_i64 ()
		# TODO: I don't know if i can rely on the initial unit to always be KiB
		|> string.concat "MiB";

	string.concat reserved, "/", total, " memory"
		|> label_color palette.white
};

let battery = {
	let { command, label_color } = psybeam;
	let { string, iter, option } = std;
	let palette = palette;
	let read_file = read_file;

	with _widget;

	let property = {
		# run `ls /sys/class/power_supply` to see possible batteries.
		let battery = "BAT0";
		let string = string;
		with property;
		string.concat "/sys/class/power_supply/", battery, "/", property
	};
	let capacity = read_file (property "capacity")
		|> string.trim_whitespace ();
	let status = read_file (property "status")
		|> string.trim_whitespace ();

	string.concat capacity, "% ", status
		|> label_color palette.pink
};

let clock = {
	let { command, label_color } = psybeam;
	let { iter, string, option } = std;
	let palette = palette;

	with _widget;

	(command "date", "+%H:%M").stdout
		|> string.trim_whitespace ()
		|> label_color palette.red
};

network,
	psybeam.spacer,
cpu, memory, battery,
	psybeam.spacer,
clock
